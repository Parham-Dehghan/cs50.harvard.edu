# cs50.harvard.edu

<style>
/* انیمیشن محو شدن برای تصاویر */
@keyframes fadeIn {
  0% { opacity: 0; transform: scale(0.95); }
  100% { opacity: 1; transform: scale(1); }
}

.fade-in {
  animation: fadeIn 1s ease-in-out;
}

/* تنظیمات برای کدهای LTR */
pre, code {
  direction: ltr;
  text-align: left;
  unicode-bidi: embed;
}

/* استایل کلی برای راست‌به‌چپ */
body {
  font-family: 'Vazir', sans-serif; /* فونت فارسی */
}
</style>

<div dir="rtl" style="text-align: right; font-family: 'Vazir', sans-serif;">

# درسنامه صفر

## خوش آمدید!

+ این درس فراتر از برنامه‌نویسی کامپیوتری است! مهارت‌های عملی که در این درس خواهید آموخت، می‌توانند تأثیر زیادی بر زندگی و یادگیری شما فراتر از علوم کامپیوتر داشته باشند.
+ در واقع، این درس درباره حل مسئله به روشی بسیار توانمند است! احتمالاً مهارت‌های حل مسئله‌ای که در اینجا می‌آموزید، بلافاصله در کارهای دیگرتان، حتی در کل حرفه‌تان، قابل استفاده خواهد بود!
+ با این حال، آسان نخواهد بود! در طول این دوره، شما از «شلنگ آتش‌نشانی» دانش خواهید نوشید. شگفت‌زده خواهید شد از آنچه در هفته‌های آینده قادر به انجامش خواهید بود.
+ این دوره بیشتر درباره پیشرفت «شما» از «جایی که امروز هستید» است تا رسیدن به یک استاندارد خیالی.
+ مهم‌ترین نکته در شروع این دوره: زمانی که نیاز دارید را به یادگیری اختصاص دهید. هر کس به شیوه‌ای متفاوت یاد می‌گیرد. اگر در ابتدا چیزی خوب پیش نرفت، بدانید که با زمان، مهارت‌هایتان رشد خواهد کرد.
+ اگر این اولین کلاس علوم کامپیوتر شماست، نترسید! برای اکثر هم‌کلاسی‌هایتان هم این اولین تجربه است! علاوه بر این، دستیاران آموزشی، کمک‌مربیان و جامعه هم‌کلاسی‌هایتان اینجا هستند تا به شما کمک کنند!

## جامعه!

* شما بخشی از جامعه‌ای هستید که این درس را در کالج هاروارد، مدرسه آموزش مداوم هاروارد و از طریق edX.org می‌گذرانند.
* امیدواریم (چه به‌صورت حضوری و چه مجازی) به ما در روز پازل CS50 و نمایشگاه CS50 بپیوندید.
* اگر دانشجوی campus هاروارد هستید، می‌توانید در ناهارهای CS50 و هکاتون CS50 شرکت کنید.

## علوم کامپیوتر و حل مسئله

* اساساً، برنامه‌نویسی کامپیوتری درباره دریافت ورودی و تولید خروجی است - و در نتیجه حل یک مسئله. آنچه بین ورودی و خروجی اتفاق می‌افتد، که می‌توانیم آن را جعبه سیاه بنامیم، تمرکز این درس است.

  <img src="https://cs50.harvard.edu/x/2025/notes/0/black_box.png" alt="جعبه سیاه با ورودی و خروجی" class="fade-in" style="max-width: 100%; height: auto;">

* به عنوان مثال، ممکن است نیاز باشد حضور و غیاب یک کلاس را ثبت کنیم. می‌توانیم از سیستمی به نام یکانی (یا پایه-۱) استفاده کنیم که با انگشتان یکی‌یکی می‌شمارد.
* کامپیوترهای امروزی با استفاده از سیستم دودویی (باینری) می‌شمارند. از اصطلاح «دیجیت دودویی» است که واژه آشنا «بیت» به دست می‌آید. بیت یک صفر یا یک است: خاموش یا روشن.
* کامپیوترها فقط با صفر و یک صحبت می‌کنند. صفر نشان‌دهنده خاموش و یک نشان‌دهنده روشن است. کامپیوترها از میلیون‌ها یا شاید میلیاردها ترانزیستور تشکیل شده‌اند که روشن و خاموش می‌شوند.
* اگر یک لامپ را تصور کنید، یک لامپ تنها می‌تواند از صفر تا یک را بشمارد.
* اما اگر سه لامپ داشته باشید، گزینه‌های بیشتری خواهید داشت!
* در داخل آیفون شما، میلیون‌ها لامپ به نام ترانزیستور وجود دارد که فعالیت‌هایی را که هر روز بدیهی می‌دانید، ممکن می‌سازد.
* به عنوان یک روش ساده، می‌توانیم تصور کنیم که مقادیر زیر هر جایگاه ممکن در عدد دودویی را نشان می‌دهند:

  ```plaintext
  ۴ ۲ ۱
  ```
* با استفاده از سه لامپ، موارد زیر می‌تواند صفر را نشان دهد:

  ```plaintext
  ۴ ۲ ۱
  ۰ ۰ ۰
  ```
* به همین ترتیب، موارد زیر یک را نشان می‌دهد:

  ```plaintext
  ۴ ۲ ۱
  ۰ ۰ ۱
  ```
* با این منطق، می‌توان پیشنهاد کرد که موارد زیر برابر با دو است:

  ```plaintext
  ۴ ۲ ۱
  ۰ ۱ ۰
  ```
* با گسترش این منطق، موارد زیر سه را نشان می‌دهد:

  ```plaintext
  ۴ ۲ ۱
  ۰ ۱ ۱
  ```
* چهار به این صورت خواهد بود:

  ```plaintext
  ۴ ۲ ۱
  ۱ ۰ ۰
  ```
* در واقع، با استفاده از تنها سه لامپ می‌توانیم تا هفت بشماریم!

  ```plaintext
  ۴ ۲ ۱
  ۱ ۱ ۱
  ```
* کامپیوترها از پایه-۲ برای شمارش استفاده می‌کنند. این را می‌توان به این صورت تصور کرد:

  ```plaintext
  ۲^۲  ۲^۱  ۲^۰
  ۴    ۲    ۱
  ```
* بنابراین، می‌توان گفت که برای نمایش عددی به بزرگی هفت، به سه بیت (جایگاه چهار، دو و یک) نیاز است.
* به همین ترتیب، برای شمارش عددی تا هشت، مقادیر به این صورت نمایش داده می‌شوند:

  ```plaintext
  ۸ ۴ ۲ ۱
  ۱ ۰ ۰ ۰
  ```
* کامپیوترها معمولاً از هشت بیت (که به آن بایت نیز گفته می‌شود) برای نمایش یک عدد استفاده می‌کنند. به عنوان مثال، `00000101` عدد ۵ در دودویی است. `11111111` عدد ۲۵۵ را نشان می‌دهد. صفر را می‌توان به این صورت تصور کرد:

  | ۱۲۸ | ۶۴ | ۳۲ | ۱۶ | ۸ | ۴ | ۲ | ۱ |
  |-----|----|----|----|---|----|----|---|
  | ۰   | ۰  | ۰  | ۰  | ۰ | ۰  | ۰  | ۰ |

## ASCII

* همان‌طور که اعداد با الگوهای دودویی از صفر و یک نمایش داده می‌شوند، حروف نیز با صفر و یک نمایش داده می‌شوند!
* از آنجا که بین صفرها و یک‌هایی که اعداد و حروف را نشان می‌دهند همپوشانی وجود دارد، استاندارد ASCII ایجاد شد تا حروف خاص را به اعداد خاص نگاشت کند.
* به عنوان مثال، تصمیم گرفته شد که حرف `A` به عدد ۶۵ نگاشت شود. `01000001` عدد ۶۵ در دودویی است. این را می‌توان به این صورت تجسم کرد:

  | ۱۲۸ | ۶۴ | ۳۲ | ۱۶ | ۸ | ۴ | ۲ | ۱ |
  |-----|----|----|----|---|----|----|---|
  | ۰   | ۱  | ۰ cooperation | ۰  | ۰ | ۰  | ۰  | ۱ |
* اگر یک پیام متنی دریافت کنید، ممکن است باینری زیر آن پیام اعداد ۷۲، ۷۳ و ۳۳ را نشان دهد. با نگاشت این‌ها به ASCII، پیام شما به این صورت خواهد بود:

  ```plaintext
  H   I   !
  ۷۲  ۷۳  ۳۳
  ```
* خدا را شکر برای استانداردهایی مثل ASCII که به ما اجازه می‌دهند روی این مقادیر توافق کنیم!
* در اینجا یک نقشه گسترده‌تر از مقادیر ASCII آورده شده است:

  | ۰ | NUL | ۱۶ | DLE | ۳۲ | SP | ۴۸ | ۰ | ۶۴ | @ | ۸۰ | P | ۹۶ | ` | ۱۱۲ | p |
  |---|-----|----|-----|----|----|----|---|----|----|----|----|----|
  | ۱ | SOH | ۱۷ | DC1 | ۳۳ | ! | ۴۹ | ۱ | ۶۵ | A | ۸۱ | Q | ۹۷ | a | ۱۱۳ | q |
  | ۲ | STX | ۱۸ | DC2 | ۳۴ | " | ۵۰ | ۲ | ۶۶ | B | ۸۲ | R | ۹۸ | b | ۱۱۴ | r |
  | ۳ | ETX | ۱۹ | DC3 | ۳۵ | # | ۵۱ | ۳ | ۶۷ | C | ۸۳ | S | ۹۹ | c | ۱۱۵ | s |
  | ۴ | EOT | ۲۰ | DC4 | ۳۶ | $ | ۵۲ | ۴ | ۶۸ | D | ۸۴ | T | ۱۰۰ | d | ۱۱۶ | t |
  | ۵ | ENQ | ۲۱ | NAK | ۳۷ | % | ۵۳ | ۵ | ۶۹ | E | ۸۵ | U | ۱۰۱ | e | ۱۱۷ | u |
  | ۶ | ACK | ۲۲ | SYN | ۳۸ | & | ۵۴ | ۶ | ۷۰ | F | ۸۶ | V | ۱۰۲ | f | ۱۱۸ | v |
  | ۷ | BEL | ۲۳ | ETB | ۳۹ | ' | ۵۵ | ۷ | ۷۱ | G | ۸۷ | W | ۱۰۳ | g | ۱۱۹ | w |
  | ۸ | BS | ۲۴ | CAN | ۴۰ | ( | ۵۶ | ۸ | ۷۲ | H | ۸۸ | X | ۱۰۴ | h | ۱۲۰ | x |
  | ۹ | HT | ۲۵ | EM | ۴۱ | ) | ۵۷ | ۹ | ۷۳ | I | ۸۹ | Y | ۱۰۵ | i | ۱۲۱ | y |
  | ۱۰ | LF | ۲۶ | SUB | ۴۲ | * | ۵۸ | : | ۷۴ | J | ۹۰ | Z | ۱۰۶ | j | ۱۲۲ | z |
  | ۱۱ | VT | ۲۷ | ESC | ۴۳ | + | ۵۹ | ; | ۷۵ | K | ۹۱ | [ | ۱۰۷ | k | ۱۲۳ | { |
  | ۱۲ | FF | ۲۸ | FS | ۴۴ | , | ۶۰ | < | ۷۶ | L | ۹۲ | \ | ۱۰۸ | l | ۱۲۴ | | |
  | ۱۳ | CR | ۲۹ | GS | ۴۵ | - | ۶۱ | = | ۷۷ | M | ۹۳ | ] | ۱۰۹ | m | ۱۲۵ | } |
  | ۱۴ | SO | ۳۰ | RS | ۴۶ | . | ۶۲ | > | ۷۸ | N | ۹۴ | ^ | ۱۱۰ | n | ۱۲۶ | ~ |
  | ۱۵ | SI | ۳۱ | US | ۴۷ | / | ۶۳ | ? | ۷۹ | O | ۹۵ | _ | ۱۱۱ | o | ۱۲۷ | DEL |

* اگر بخواهید، می‌توانید درباره <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> بیشتر یاد بگیرید.
* از آنجا که باینری تنها تا ۲۵۵ می‌تواند بشمارد، ما به تعداد کاراکترهایی که ASCII می‌تواند نمایش دهد محدود هستیم.

## یونیکد

* با گذشت زمان، راه‌های بیشتری برای ارتباط از طریق متن به وجود آمده است.
* از آنجا که بیت‌های کافی در باینری برای نمایش همه کاراکترهای مختلفی که انسان‌ها می‌توانند استفاده کنند وجود نداشت، استاندارد یونیکد تعداد بیت‌هایی که می‌توانند توسط کامپیوترها منتقل و فهمیده شوند را گسترش داد. یونیکد نه تنها کاراکترهای خاص، بلکه ایموجی‌ها را نیز شامل می‌شود.
* ایموجی‌هایی وجود دارند که احتمالاً هر روز استفاده می‌کنید. موارد زیر ممکن است برایتان آشنا باشند:

  😀 😃 😄 😁 😆 😅 😂 🙂 🙃 😉 😊 😇 😍 😘 😗 😙 😚 😋 😛 😜 😝 🤑 🤓 😎 🤗 😏 😶 😐 😑 😒 🙄 😬 😕 ☹️ 😟 😮 😯 😲 😳 😦 😧 😨

* در حالی که الگوی صفرها و یک‌ها در یونیکد استاندارد شده است، هر سازنده دستگاه ممکن است هر ایموجی را کمی متفاوت از دیگری نمایش دهد.
* ویژگی‌های بیشتری به استاندارد یونیکد اضافه می‌شود تا کاراکترها و ایموجی‌های بیشتری را نمایش دهد.
* اگر بخواهید، می‌توانید درباره <a href="https://en.wikipedia.org/wiki/Unicode">یونیکد</a> بیشتر یاد بگیرید.
* اگر بخواهید، می‌توانید درباره <a href="https://en.wikipedia.org/wiki/Emoji">ایموجی‌ها</a> بیشتر یاد بگیرید.

## RGB

* صفرها و یک‌ها می‌توانند برای نمایش رنگ استفاده شوند.
* قرمز، سبز و آبی (که به آن `RGB` گفته می‌شود) ترکیبی از سه عدد هستند.

  <img src="https://cs50.harvard.edu/x/2025/notes/0/rgb.png" alt="جعبه‌های قرمز، سبز و آبی" class="fade-in" style="max-width: 100%; height: auto;">

* اگر اعداد ۷۲، ۷۳ و ۳۳ که قبلاً به صورت متنی `HI!` را نشان می‌دادند، توسط خوانندگان تصویر تفسیر شوند، به صورت یک سایه روشن زرد نمایش داده می‌شوند. مقدار قرمز ۷۲، مقدار سبز ۷۳ و مقدار آبی ۳۳ خواهد بود.

  <img src="https://cs50.harvard.edu/x/2025/notes/0/yellow.png" alt="جعبه زرد" class="fade-in" style="max-width: 100%; height: auto;">

* سه بایت مورد نیاز برای نمایش رنگ‌های مختلف قرمز، آبی و سبز (یا RGB) هر پیکسل (یا نقطه) رنگی در هر تصویر دیجیتال را تشکیل می‌دهند. تصاویر صرفاً مجموعه‌ای از مقادیر RGB هستند.
* صفرها و یک‌ها می‌توانند برای نمایش تصاویر، ویدئوها و موسیقی استفاده شوند!
* ویدئوها دنباله‌ای از تصاویر بسیاری هستند که با هم ذخیره شده‌اند، مانند یک دفترچه ورق‌زن.
* موسیقی نیز می‌تواند به طور مشابه با استفاده از ترکیب‌های مختلف بایت‌ها نمایش داده شود.

## الگوریتم‌ها

* حل مسئله در مرکز علوم کامپیوتر و برنامه‌نویسی قرار دارد. الگوریتم مجموعه‌ای از دستورالعمل‌های گام به گام برای حل یک مسئله است.
* تصور کنید مسئله ساده پیدا کردن یک نام در دفترچه تلفن را دارید.
* چگونه می‌توان به این مسئله پرداخت؟
* یک رویکرد می‌تواند این باشد که از صفحه اول به صفحه بعدی و بعدی بخوانید تا به صفحه آخر برسید.
* رویکرد دیگر می‌تواند جستجوی دو صفحه در یک زمان باشد.
* رویکرد نهایی و شاید بهتر این باشد که به وسط دفترچه تلفن بروید و بپرسید: «آیا نامی که به دنبالش هستم در سمت چپ است یا راست؟» سپس، این فرآیند را تکرار کنید و مسئله را به نصف و نصف و نصف تقسیم کنید.
* هر یک از این رویکردها می‌توانند الگوریتم نامیده شوند. سرعت هر یک از این الگوریتم‌ها را می‌توان به صورت زیر در نماد بیگ-او (big-O) نمایش داد:

  <img src="https://cs50.harvard.edu/x/2025/notes/0/big_o.png" alt="نماد بیگ-او" class="fade-in" style="max-width: 100%; height: auto;">

  توجه کنید که الگوریتم اول، که به رنگ قرمز مشخص شده، دارای بیگ-او `n` است زیرا اگر ۱۰۰ نام در دفترچه تلفن باشد، ممکن است تا ۱۰۰ تلاش طول بکشد تا نام درست را پیدا کنید. الگوریتم دوم، که دو صفحه را همزمان جستجو می‌کرد، دارای بیگ-او `n/2` است زیرا ما دو برابر سریع‌تر صفحات را جستجو کردیم. الگوریتم نهایی دارای بیگ-او `log 2n` است، زیرا دو برابر کردن مسئله تنها یک گام اضافی برای حل مسئله نیاز دارد.
* برنامه‌نویسان دستورالعمل‌های مبتنی بر متن انسانی را به کد ترجمه می‌کنند.

## شبه‌کد (Pseudocode)

* فرآیند تبدیل دستورالعمل‌ها به کد، شبه‌کد نامیده می‌شود.
* توانایی ایجاد شبه‌کد برای موفقیت در این درس و در برنامه‌نویسی کامپیوتری بسیار مهم است.
* شبه‌کد نسخه‌ای قابل خواندن برای انسان از کد شماست. به عنوان مثال، با در نظر گرفتن الگوریتم سوم بالا، می‌توانیم شبه‌کد را به این صورت بنویسیم:

  ```plaintext
  ۱  دفترچه تلفن را بردار
  ۲  به وسط دفترچه تلفن باز کن
  ۳  به صفحه نگاه کن
  ۴  اگر شخص در صفحه است
  ۵      با شخص تماس بگیر
  ۶  در غیر این صورت اگر شخص در بخش ابتدایی کتاب است
  ۷      به وسط نیمه چپ کتاب باز کن
  ۸      به خط ۳ برگرد
  ۹  در غیر این صورت اگر شخص در بخش بعدی کتاب است
  ۱۰     به وسط نیمه راست کتاب باز کن
  ۱۱     به خط ۳ برگرد
  ۱۲ در غیر این صورت
  ۱۳     خارج شو
  ```
* شبه‌کد نویسی به دو دلیل بسیار مهم است. اول، وقتی قبل از نوشتن کد رسمی شبه‌کد می‌نویسید، به شما امکان می‌دهد منطق مسئله‌تان را از قبل فکر کنید. دوم، وقتی شبه‌کد می‌نویسید، می‌توانید این اطلاعات را به دیگرانی که به دنبال درک تصمیمات کدنویسی شما و نحوه عملکرد کدتان هستند، ارائه دهید.
* توجه کنید که زبان در شبه‌کد ما ویژگی‌های منحصربه‌فردی دارد. اول، برخی از این خطوط با افعالی مانند بردار، باز کن، نگاه کن شروع می‌شوند. بعداً، ما این‌ها را توابع (functions) می‌نامیم.
* دوم، توجه کنید که برخی خطوط شامل عباراتی مانند `if` یا `else if` هستند. این‌ها شرطی‌ها (conditionals) نامیده می‌شوند.
* سوم، توجه کنید که عباراتی وجود دارند که می‌توانند به صورت درست یا نادرست بیان شوند، مانند «شخص در بخش ابتدایی کتاب است.» ما این‌ها را عبارات بولی (boolean expressions) می‌نامیم.
* در نهایت، توجه کنید که عباراتی مانند «به خط ۳ briberd» وجود دارد. ما این‌ها را حلقه‌ها (loops) می‌نامیم.
* این بلوک‌های سازنده، اصول اولیه برنامه‌نویسی هستند.
* در زمینه اسکرچ (Scratch)، که در ادامه بحث می‌شود، ما از هر یک از بلوک‌های سازنده اولیه بالا استفاده خواهیم کرد.

## هوش مصنوعی

* در نظر بگیرید که چگونه می‌توانیم از بلوک‌های سازنده بالا برای شروع ایجاد هوش مصنوعی خودمان استفاده کنیم. به شبه‌کد زیر نگاه کنید:

  ```plaintext
  اگر دانش‌آموز بگوید سلام
  بگو سلام
  در غیر این صورت اگر دانش‌آموز بگوید خداحافظ
  بگو خداحافظ
  در غیر این صورت اگر دانش‌آموز بپرسد حالت چطور است
  بگو خوبم
  در غیر این صورت اگر دانش‌آموز بپرسد چرا ۱۱۱ در باینری برابر با ۷ در دسیمال است
  ...
  ```

  توجه کنید که برای برنامه‌ریزی تعداد کمی تعامل، خطوط زیادی کد مورد نیاز است. برای هزاران یا ده‌ها هزار تعامل ممکن، چند خط کد لازم خواهد بود؟
* به جای برنامه‌نویسی هوش مصنوعی مکالمه‌ای مانند بالا، برنامه‌نویسان هوش مصنوعی مدل‌های زبانی بزرگ (LLMs) را روی مجموعه‌های داده بزرگ آموزش می‌دهند.
* مدل‌های زبانی بزرگ به الگوها در بلوک‌های بزرگ زبان نگاه می‌کنند. چنین مدل‌های زبانی سعی می‌کنند بهترین حدس را درباره اینکه چه کلماتی بعد از یکدیگر یا کنار یکدیگر می‌آیند، بزنند.
* اگرچه نرم‌افزار مبتنی بر هوش مصنوعی در بسیاری از جنبه‌های زندگی و کار بسیار مفید است، ما تأکید می‌کنیم که استفاده از نرم‌افزار مبتنی بر هوش مصنوعی به جز ابزار خود CS50 معقول نیست.
* ابزار هوش مصنوعی خود CS50 به نام CS50.ai یک دستیار هوش مصنوعی است که می‌توانید در طول این دوره از آن استفاده کنید. این ابزار به شما کمک می‌کند، اما پاسخ کامل مسائل دوره را به شما نمی‌دهد.
* شما مجاز به استفاده از هیچ هوش مصنوعی در این دوره به جز CS50.ai نیستید.

## پیش رو

* این هفته درباره اسکرچ، یک زبان برنامه‌نویسی بصری، خواهید آموخت.
* سپس، در هفته‌های آینده، درباره زبان C خواهید آموخت. این چیزی شبیه به این خواهد بود:

  ```c
  #include <stdio.h>

  int main(void)
  {
      printf("hello, world\n");
  }
  ```
* با یادگیری C، برای یادگیری آینده در زبان‌های برنامه‌نویسی دیگر مانند پایتون بسیار آماده‌تر خواهید بود.
* علاوه بر این، با پیشرفت هفته‌ها، درباره الگوریتم‌ها خواهید آموخت.
* چیزی که C را چالش‌برانگیز می‌کند، علائم نگارشی آن است. با کنار گذاشتن علائم نگارشی و سینتکس برای امروز، ما فقط با ایده‌ها در یک زبان برنامه‌نویسی به نام اسکرچ کار خواهیم کرد.

## اسکرچ

* اسکرچ یک زبان برنامه‌نویسی بصری است که توسط MIT توسعه یافته است.
* اسکرچ از همان بلوک‌های سازنده برنامه‌نویسی که قبلاً در این درس پوشش دادیم استفاده می‌کند.
* اسکرچ راهی عالی برای ورود به برنامه‌نویسی کامپیوتری است زیرا به شما امکان می‌دهد با این بلوک‌های سازنده به صورت بصری بازی کنید، بدون اینکه نگران سینتکس‌هایی مانند کروشه‌ها، نقطه‌ویرگول‌ها، پرانتزها و غیره باشید.
* محیط توسعه یکپارچه (IDE) اسکرچ به این صورت است:

  <img src="https://cs50.harvard.edu/x/2025/notes/0/scratch_interface.png" alt="رابط اسکرچ" class="fade-in" style="max-width: 100%; height: auto;">

  توجه کنید که در سمت چپ، یک پالت از بلوک‌های سازنده وجود دارد که می‌توانید در برنامه‌نویسی خود از آن‌ها استفاده کنید. در سمت راست این بلوک‌ها، ناحیه‌ای است که می‌توانید بلوک‌ها را به آن بکشید تا یک برنامه بسازید. در سمت راست آن، صحنه‌ای را می‌بینید که یک گربه روی آن ایستاده است. صحنه جایی است که برنامه‌نویسی شما زنده می‌شود.
* اسکرچ بر اساس یک سیستم مختصات به این صورت عمل می‌کند:

  <img src="https://cs50.harvard.edu/x/2025/notes/0/scratch_coordinate_system.png" alt="سیستم مختصات اسکرچ" class="fade-in" style="max-width: 100%; height: auto;">

  توجه کنید که مرکز صحنه در مختصات (۰,۰) قرار دارد. در حال حاضر، موقعیت گربه نیز در همان مختصات است.

## سلام، دنیا

* برای شروع، بلوک «وقتی پرچم سبز کلیک شد» را به ناحیه برنامه‌نویسی بکشید. سپس، بلوک `say` را به ناحیه برنامه‌نویسی بکشید و آن را به بلوک قبلی متصل کنید.

  ```plaintext
  وقتی پرچم سبز کلیک شد
  بگو [سلام، دنیا]
  ```

  توجه کنید که وقتی اکنون پرچم سبز را روی صحنه کلیک کنید، گربه می‌گوید: «سلام، دنیا».
* این موضوع کاملاً آنچه را که قبلاً درباره برنامه‌نویسی بحث کردیم نشان می‌دهد:

  <img src="https://cs50.harvard.edu/x/2025/notes/0/scratch_black_box.png" alt="اسکرچ با جعبه سیاه" class="fade-in" style="max-width: 100%; height: auto;">

  توجه کنید که ورودی `سلام، دنیا` به تابع `say` منتقل می‌شود و اثر جانبی اجرای آن تابع این است که گربه می‌گوید: «سلام، دنیا».

## سلام، شما

* می‌توانیم برنامه‌تان را تعاملی‌تر کنیم تا گربه به شخص خاصی سلام کند. برنامه‌تان را به این صورت اصلاح کنید:

  ```plaintext
  وقتی پرچم سبز کلیک شد
  بپرس [اسمت چیه؟] و صبر کن
  بگو (اتصال [سلام،] (پاسخ))
  ```

  توجه کنید که وقتی پرچم سبز کلیک می‌شود، تابع `ask` اجرا می‌شود. برنامه از شما، کاربر، می‌پرسد: «اسمت چیه؟» سپس نام را در متغیری به نام `answer` ذخیره می‌کند. برنامه سپس `answer` را به یک تابع خاص به نام `join` منتقل می‌کند که دو رشته متنی `سلام،` و هر نامی که ارائه شده را ترکیب می‌کند. به معنای واقعی، `answer` یک مقدار به `join` برمی‌گرداند. این‌ها به طور جمعی به تابع `say` منتقل می‌شوند. گربه می‌گوید: «سلام،» و یک نام. حالا برنامه شما تعاملی است.
* در طول این دوره، شما ورودی‌هایی را به یک الگوریتم ارائه خواهید داد و خروجی‌ها (یا اثرات جانبی) دریافت خواهید کرد. این را می‌توان در مورد برنامه بالا به این صورت تصور کرد:

  <img src="https://cs50.harvard.edu/x/2025/notes/0/scratch_algorithm.png" alt="اسکرچ به عنوان الگوریتم" class="fade-in" style="max-width: 100%; height: auto;">

  توجه کنید که ورودی‌های `سلام،` و `answer` به `join` ارائه می‌شوند و نتیجه آن اثر جانبی `سلام، دیوید` است.
* به طور مشابه، می‌توانیم برنامه‌مان را به این صورت اصلاح کنیم:

  ```plaintext
  وقتی پرچم سبز کلیک شد
  بپرس [اسمت چیه؟] و صبر کن
  صحبت کن (اتصال [سلام،] (پاسخ))
  ```

  توجه کنید که این برنامه، وقتی پرچم سبز کلیک می‌شود، همان متغیر را که با `سلام،` ترکیب شده، به تابع `speak` منتقل می‌کند.

## میو و انتزاع

* همراه با شبه‌کد نویسی، انتزاع یک مهارت و مفهوم اساسی در برنامه‌نویسی کامپیوتری است.
* انتزاع عمل ساده‌سازی یک مسئله به مسائل کوچک‌تر و کوچک‌تر است.
* به عنوان مثال، اگر در حال میزبانی یک شام بزرگ برای دوستانتان باشید، وظیفه پخت کل غذا می‌تواند بسیار طاقت‌فرسا باشد! اما اگر وظیفه پخت غذا را به وظایف کوچک‌تر و کوچک‌تر (یا مسائل) تقسیم کنید، وظیفه بزرگ ایجاد این غذای خوشمزه ممکن است کمتر چالش‌برانگیز به نظر برسد.
* در برنامه‌نویسی، و حتی در اسکرچ، می‌توانیم انتزاع را در عمل ببینیم. در ناحیه برنامه‌نویسی خود، به این صورت برنامه‌نویسی کنید:

  ```plaintext
  وقتی پرچم سبز کلیک شد
  صدا پخش کن (میو v) تا پایان
  صبر کن (۱) ثانیه
  صدا پخش کن (میو v) تا پایان
  صبر کن (۱) ثانیه
  صدا پخش کن (میو v) تا پایان
  ```

  توجه کنید که شما بارها و بارها همان کار را انجام می‌دهید. در واقع، اگر ببینید که بارها همان عبارات را کد می‌کنید، احتمالاً می‌توانید با هنر بیشتری برنامه‌نویسی کنید - با انتزاع این کد تکراری.
* می‌توانید کد خود را به این صورت اصلاح کنید:

  ```plaintext
  وقتی پرچم سبز کلیک شد
  تکرار کن (۳)
  صدا پخش کن (میو v) تا پایان
  صبر کن (۱) ثانیه
  ```

  توجه کنید که حلقه دقیقاً همان کاری را که برنامه قبلی انجام می‌داد، انجام می‌دهد. اما مسئله با انتزاع تکرار به یک بلوک که کد را برای ما تکرار می‌کند، ساده‌سازی شده است.
* حتی می‌توانیم این را بیشتر پیش ببریم با استفاده از بلوک `define`، که در آن می‌توانید بلوک خودتان (تابع خودتان) را ایجاد کنید! به این صورت کد بنویسید:

  ```plaintext
  تعریف کن میو
  صدا پخش کن (میو v) تا پایان
  صبر کن (۱) ثانیه

  وقتی پرچم سبز کلیک شد
  تکرار کن (۳)
  میو
  ```

  توجه کنید که ما بلوک خودمان به نام `میو` را تعریف می‌کنیم. این تابع صدای `میو` را پخش می‌کند و سپس یک ثانیه صبر می‌کند. در زیر آن، می‌بینید که وقتی پرچم سبز کلیک می‌شود، تابع میو ما سه بار تکرار می‌شود.
* حتی می‌توانیم راهی فراهم کنیم که تابع یک ورودی `n` بگیرد و به تعداد دلخواه تکرار شود:

  ```plaintext
  تعریف کن میو n بار
  تکرار کن (n)
  صدا پخش کن [میو v] تا پایان
  صبر کن (۱) ثانیه
  ```

  توجه کنید که `n` از «میو n بار» گرفته شده است. `n` از طریق بلوک `define` به تابع میو منتقل می‌شود.
* به طور کلی، توجه کنید که این فرآیند بهبود منجر به کدهایی با طراحی بهتر و بهتر شد. علاوه بر این، توجه کنید که چگونه الگوریتم خودمان را برای حل یک مسئله ایجاد کردیم. شما در طول این دوره هر دو این مهارت‌ها را تمرین خواهید کرد.

## شرطی‌ها

* شرطی‌ها یک بلوک سازنده اساسی برنامه‌نویسی هستند، جایی که برنامه بررسی می‌کند که آیا شرط خاصی برآورده شده است یا خیر. اگر شرط برآورده شد، برنامه کاری انجام می‌دهد.
* برای نشان دادن یک شرطی، به این صورت کد بنویسید:

  ```plaintext
  وقتی پرچم سبز کلیک شد
  برای همیشه
  اگر <در حال لمس (اشاره‌گر ماوس v)؟> سپس
  صدا پخش کن (میو v) تا پایان
  ```

  توجه کنید که بلوک `برای همیشه` استفاده شده است تا بلوک `اگر` بارها و بارها فعال شود، به طوری که بتواند به طور مداوم بررسی کند که آیا گربه به اشاره‌گر ماوس برخورد می‌کند یا خیر.
* می‌توانیم برنامه‌مان را به این صورت اصلاح کنیم تا حسگر ویدئویی را ادغام کنیم:

  ```plaintext
  وقتی حرکت ویدئو > (۱۰)
  صدا پخش کن (میو v) تا پایان
  ```
* به یاد داشته باشید، برنامه‌نویسی اغلب یک فرآیند آزمون و خطاست. اگر ناامید شدید، زمانی را صرف کنید تا مسئله‌ای که در حال کار روی آن هستید را برای خودتان توضیح دهید. مسئله خاصی که اکنون روی آن کار می‌کنید چیست؟ چه چیزی کار می‌کند؟ چه چیزی کار نمی‌کند؟

## زمان اسکار

* زمان اسکار یکی از برنامه‌های اسکرچ خود دیوید است – اگرچه موسیقی ممکن است او را آزار دهد به دلیل تعداد ساعاتی که هنگام ایجاد این برنامه به آن گوش داده است. چند لحظه وقت بگذارید تا خودتان این بازی را امتحان کنید.
* برای ساخت زمان اسکار خودمان، ابتدا تیر چراغ برق را اضافه می‌کنیم.

  <img src="https://cs50.harvard.edu/x/2025/notes/0/oscartime.png" alt="رابط زمان اسکار" class="fade-in" style="max-width: 100%; height: auto;">

* سپس، به این صورت کد بنویسید:

  ```plaintext
  وقتی پرچم سبز کلیک شد
  لباس را به (اسکار۱ v) تغییر بده
  برای همیشه
  اگر <در حال لمس (اشاره‌گر ماوس v)؟> سپس
  لباس را به (اسکار۲ v) تغییر بده
  در غیر این صورت
  لباس را به (اسکار۱ v) تغییر بده
  ```

  توجه کنید که حرکت ماوس روی اسکار لباس او را تغییر می‌دهد. با کاوش این بلوک‌های کد می‌توانید بیشتر یاد بگیرید.
* سپس، کد خود را به این صورت اصلاح کنید تا یک تکه زباله در حال سقوط ایجاد شود:

  ```plaintext
  وقتی پرچم سبز کلیک شد
  برو به x: (انتخاب تصادفی (-۲۴۰) تا (۲۴۰)) y: (۱۸۰)
  برای همیشه
  اگر <(فاصله تا (کف v)) > (۰)> سپس
  y را به (-۳) تغییر بده
  ```

  توجه کنید که موقعیت زباله در محور y همیشه از ۱۸۰ شروع می‌شود. موقعیت x تصادفی است. در حالی که زباله بالای کف است، ۳ پیکسل در هر بار به پایین می‌رود. با کاوش این بلوک‌های کد می‌توانید بیشتر یاد بگیرید.
* در ادامه، کد خود را به این صورت اصلاح کنید تا امکان کشیدن زباله فراهم شود:

  ```plaintext
  وقتی پرچم سبز کلیک شد
  برای همیشه
  اگر <<ماوس پایین است؟> و <در حال لمس (اشاره‌گر ماوس v)؟>> سپس
  برو به (اشاره‌گر ماوس v)
  ```

  با کاوش این بلوک‌های کد می‌توانید بیشتر یاد بگیرید.
* در ادامه، متغیرهای امتیازدهی را به این صورت پیاده‌سازی می‌کنیم:

  ```plaintext
  وقتی پرچم سبز کلیک شد
  برای همیشه
  اگر <در حال لمس (اسکار v)؟> سپس
  (امتیاز) را به (۱) تغییر بده
  برو به x: (انتخاب تصادفی (-۲۴۰) تا (۲۴۰)) y: (۱۸۰)
  ```

  با کاوش این بلوک‌های کد می‌توانید بیشتر یاد بگیرید.
* بازی کامل <a href="https://scratch.mit.edu/projects/oscartime">زمان اسکار</a> را امتحان کنید.

## سخت‌ترین بازی آیوی

* با حرکت از زمان اسکار به سخت‌ترین بازی آیوی، حالا می‌توانیم تصور کنیم چگونه حرکت را در برنامه‌مان پیاده‌سازی کنیم.
* برنامه ما سه جزء اصلی دارد.
* ابتدا، به این صورت کد بنویسید:

  ```plaintext
  وقتی پرچم سبز کلیک شد
  برو به x: (۰) y: (۰)
  برای همیشه
  به صفحه‌کلید گوش کن
  دیوارها را حس کن
  ```

  توجه کنید که وقتی پرچم سبز کلیک می‌شود، sprite ما به مرکز صحنه در مختصات (۰,۰) حرکت می‌کند و سپس برای همیشه به صفحه‌کلید گوش می‌دهد و دیوارها را بررسی می‌کند.
* دوم، این گروه دوم از بلوک‌های کد را اضافه کنید:

  ```plaintext
  تعریف کن به صفحه‌کلید گوش کن
  اگر <کلید (فلش بالا v) فشرده شد؟> سپس
  y را به (۱) تغییر بده
  پایان
  اگر <کلید (فلش پایین v) فشرده شد؟> سپس
  y را به (-۱) تغییر بده
  پایان
  اگر <کلید (فلش راست v) فشرده شد؟> سپس
  x را به (۱) تغییر بده
  پایان
  اگر <کلید (فلش چپ v) فشرده شد؟> سپس
  x را به (-۱) تغییر بده
  پایان
  ```

  توجه کنید که چگونه یک اسکریپت سفارشی `به صفحه‌کلید گوش کن` ایجاد کرده‌ایم. برای هر یک از کلیدهای فلش روی صفحه‌کلید، sprite را در صفحه حرکت می‌دهد.
* در نهایت، این گروه از بلوک‌های کد را اضافه کنید:

  ```plaintext
  تعریف کن دیوارها را حس کن
  اگر <در حال لمس (دیوار چپ v)؟> سپس
  x را به (۱) تغییر بده
  پایان
  اگر <در حال لمس (دیوار راست v)؟> سپس
  x را به (-۱) تغییر بده
  پایان
  ```

  توجه کنید که چگونه یک اسکریپت سفارشی `دیوارها را حس کن` نیز داریم. وقتی sprite به دیوار برخورد می‌کند، آن را به یک موقعیت امن برمی‌گرداند - از خروج آن از صفحه جلوگیری می‌کند.
* با کاوش این بلوک‌های کد می‌توانید بیشتر یاد بگیرید.
* اسکرچ امکان حضور چندین sprite را به طور همزمان روی صفحه فراهم می‌کند.
* با اضافه کردن sprite دیگر، بلوک‌های کد زیر را به برنامه خود اضافه کنید:

  ```plaintext
  وقتی پرچم سبز کلیک شد
  برو به x: (۰) y: (۰)
  به جهت (۹۰) اشاره کن
  برای همیشه
  اگر <<در حال لمس (دیوار چپ v)؟> یا <در حال لمس (دیوار راست v)؟>> سپس
  ۱۸۰ درجه به راست بچرخ
  پایان
  (۱) قدم حرکت کن
  پایان
  ```

  توجه کنید که چگونه sprite ییل به نظر می‌رسد با حرکت به جلو و عقب، در مسیر sprite هاروارد قرار می‌گیرد. وقتی به دیوار برخورد می‌کند، برمی‌گردد تا دوباره به دیوار برخورد کند. با کاوش این بلوک‌های کد می‌توانید بیشتر یاد بگیرید.
* حتی می‌توانید یک sprite را طوری تنظیم کنید که sprite دیگری را دنبال کند. با اضافه کردن sprite دیگر، بلوک‌های کد زیر را به برنامه خود اضافه کنید:

  ```plaintext
  وقتی پرچم سبز کلیک شد
  برو به (موقعیت تصادفی v)
  برای همیشه
  به سمت (هاروارد v) اشاره کن
  (۱) قدم حرکت کن
  ```

  توجه کنید که چگونه لوگوی MIT حالا به نظر می‌رسد sprite هاروارد را دنبال می‌کند. با کاوش این بلوک‌های کد می‌توانید بیشتر یاد بگیرید.
* بازی کامل <a href="https://scratch.mit.edu/projects/ivys_hardest_game">سخت‌ترین بازی آیوی</a> را امتحان کنید.

## جمع‌بندی

در این درس، آموختید که این دوره چگونه در دنیای وسیع علوم کامپیوتر و برنامه‌نویسی قرار می‌گیرد. شما یاد گرفتید…

* تعداد کمی از دانش‌آموزان با تجربه قبلی برنامه‌نویسی به این کلاس می‌آیند!
* شما تنها نیستید! شما بخشی از یک جامعه هستید.
* حل مسئله جوهره کار دانشمندان کامپیوتر است.
* این درس فقط درباره برنامه‌نویسی نیست - این درس شما را با روش جدیدی از یادگیری آشنا می‌کند که تقریباً در هر زمینه‌ای از زندگی قابل اعمال است.
* چگونه اعداد، متن، تصاویر، موسیقی و ویدئو توسط کامپیوترها فهمیده و نمایش داده می‌شوند.
* مهارت اساسی برنامه‌نویسی به نام شبه‌کد نویسی.
* روش‌های معقول و غیرمعقول استفاده از هوش مصنوعی در این دوره.
* چگونه انتزاع در کارهای آینده شما در این دوره نقش خواهد داشت.
* بلوک‌های سازنده اساسی برنامه‌نویسی شامل توابع، شرطی‌ها، حلقه‌ها و متغیرها.
* چگونه یک پروژه در اسکرچ بسازید.

این بود CS50! خوش آمدید! تا جلسه بعدی!

</div>
